<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MonsterAI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">roguelike</a> &gt; <a href="index.source.html" class="el_package">com.nju.roguelike.world</a> &gt; <span class="el_source">MonsterAI.java</span></div><h1>MonsterAI.java</h1><pre class="source lang-java linenums">package com.nju.roguelike.world;

import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.Stack;
import java.util.Random;
import java.util.ArrayList;

public class MonsterAI extends CreatureAI {

    private List&lt;String&gt; messages;

    private World world;

<span class="nc" id="L15">    private String plan = &quot;&quot;;</span>
    private Creature player;

    public MonsterAI(Creature creature, World world, Creature player) {
<span class="nc" id="L19">        super(creature);</span>
<span class="nc" id="L20">        messages = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L21">        this.world = world;</span>
<span class="nc" id="L22">        this.player = player;</span>
<span class="nc" id="L23">    }</span>

    public void onEnter(int x, int y, Tile tile) {
<span class="nc bnc" id="L26" title="All 2 branches missed.">        if (tile.isGround()) {</span>
<span class="nc" id="L27">            creature.setX(x);</span>
<span class="nc" id="L28">            creature.setY(y);</span>
<span class="nc bnc" id="L29" title="All 2 branches missed.">        } else if (tile.isWall()) {</span>
<span class="nc" id="L30">            this.creature.dig(x, y);</span>
        }
<span class="nc" id="L32">    }</span>

    public void onNotify(String message) {
<span class="nc" id="L35">        this.messages.add(message);</span>
<span class="nc" id="L36">    }</span>

    public String getPlan() {
<span class="nc" id="L39">        return this.plan;</span>
    }

    private String[] parsePlan(String plan) {
<span class="nc" id="L43">        return plan.split(&quot;\n&quot;);</span>
    }

    // 上下左右四个方向
<span class="nc" id="L47">    int[][] towards = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };</span>

    private Node start;
    private Node finish;
<span class="nc" id="L51">    private Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span>

    public void getStep() {
        // 从当前Monster的位置走到player的位置
<span class="nc" id="L55">        plan = &quot;&quot;;</span>

<span class="nc" id="L57">        start = new Node(this.creature.x(), this.creature.y());</span>
<span class="nc" id="L58">        finish = new Node(player.x(), player.y());</span>

<span class="nc" id="L60">        stack.push(start);</span>

<span class="nc bnc" id="L62" title="All 2 branches missed.">        int mx = finish.x &gt; start.x ? 1 : -1;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        int my = finish.y &gt; start.y ? 1 : -1;</span>

<span class="nc" id="L65">        int distanceX = Math.abs(finish.x - start.x);</span>
<span class="nc" id="L66">        int distanceY = Math.abs(finish.y - start.y);</span>

        // 先横着走还是先竖着走随机
<span class="nc" id="L69">        Random rand = new Random();</span>
<span class="nc bnc" id="L70" title="All 3 branches missed.">        switch (rand.nextInt(2)) {</span>
            case 0: {
<span class="nc bnc" id="L72" title="All 2 branches missed.">                for (int i = 1; i &lt;= distanceX; ++i) {</span>
<span class="nc" id="L73">                    stack.push(new Node(start.x + mx * i, start.y));</span>
                }
<span class="nc bnc" id="L75" title="All 2 branches missed.">                for (int i = 1; i &lt;= distanceY; ++i) {</span>
<span class="nc" id="L76">                    stack.push(new Node(finish.x, start.y + my * i));</span>
                }
<span class="nc" id="L78">                break;</span>
            }
            case 1: {
<span class="nc bnc" id="L81" title="All 2 branches missed.">                for (int i = 1; i &lt;= distanceY; ++i) {</span>
<span class="nc" id="L82">                    stack.push(new Node(start.x, start.y + my * i));</span>
                }
<span class="nc bnc" id="L84" title="All 2 branches missed.">                for (int i = 1; i &lt;= distanceX; ++i) {</span>
<span class="nc" id="L85">                    stack.push(new Node(start.x + mx * i, finish.y));</span>
                }
                break;
            }
        }

        /*
         * if(this.canSee(player.x(), player.y())){
         * // 怪物能看见玩家，距离近，直接走不尝试绕墙
         * 
         * }else{
         * // 尝试绕开墙壁
         * int [][]status = new int[World.WIDTH][World.HEIGHT];
         * stack.push(start);
         * status[start.x][start.y] = 1;
         * 
         * boolean judge0 = false;
         * 
         * while (!stack.empty() &amp;&amp; !judge0) {
         * Node next = stack.peek();
         * //遍历周边节点
         * boolean judge = false;
         * for(int i = 0; i &lt; 4; ++i)
         * {
         * int x0 = next.x + towards[i][0];
         * int y0 = next.y + towards[i][1];
         * if(x0 &gt;= 0 &amp;&amp; x0 &lt; World.WIDTH &amp;&amp; y0 &gt;= 0 &amp;&amp; y0 &lt; World.HEIGHT &amp;&amp;
         * world.tile(x0, y0).isGround() &amp;&amp; status[x0][y0] == 0)
         * {//可尝试的节点
         * status[x0][y0] = 1;
         * stack.push(new Node(x0, y0));
         * if(x0 == finish.x &amp;&amp; y0 == finish.y)
         * {//找到终点
         * judge0 = true;
         * }
         * judge = true;
         * break;
         * }
         * }
         * if(!judge){
         * stack.pop();
         * }
         * }
         * }
         */

        // 把路径摆正
<span class="nc" id="L132">        Stack&lt;Node&gt; route = new Stack&lt;&gt;();</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        while (!stack.empty()) {</span>
<span class="nc" id="L134">            Node tempNode = stack.pop();</span>
<span class="nc" id="L135">            route.push(tempNode);</span>
<span class="nc" id="L136">        }</span>

        Node next;
<span class="nc bnc" id="L139" title="All 2 branches missed.">        while (!route.empty()) {</span>
<span class="nc" id="L140">            next = route.pop();</span>
<span class="nc" id="L141">            plan += &quot;&quot; + next.x + &quot;,&quot; + next.y + &quot;\n&quot;;</span>
        }
<span class="nc" id="L143">        return;</span>

    }

    private void execute(String step) {
<span class="nc" id="L148">        String[] couple = step.split(&quot;,&quot;);</span>

<span class="nc" id="L150">        int nextX = Integer.parseInt(couple[0]);</span>
<span class="nc" id="L151">        int nextY = Integer.parseInt(couple[1]);</span>

<span class="nc" id="L153">        int mx = nextX - this.creature.x();</span>
<span class="nc" id="L154">        int my = nextY - this.creature.y();</span>
<span class="nc" id="L155">        creature.moveBy(mx, my);</span>
<span class="nc" id="L156">    }</span>

    @Override
    public void run() {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        while (this.creature.hp() &gt; 0) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if (creature.getStatus()) { // 处于运行状态再跑</span>
<span class="nc" id="L162">                getStep();</span>
<span class="nc" id="L163">                String[] walkSteps = parsePlan(plan);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (walkSteps.length &gt; 1) {</span>
<span class="nc" id="L165">                    execute(walkSteps[1]);</span>
                }
            }

            try {
<span class="nc" id="L170">                TimeUnit.MILLISECONDS.sleep(400);</span>
<span class="nc" id="L171">            } catch (InterruptedException e) {</span>
                // TODO: handle exception
<span class="nc" id="L173">                e.printStackTrace();</span>
<span class="nc" id="L174">            }</span>
<span class="nc" id="L175">            Thread.yield();</span>
        }
<span class="nc" id="L177">        return;</span>
    }
}

class Node {
    public final int x;
    public final int y;

<span class="nc" id="L185">    public Node(int x, int y) {</span>
<span class="nc" id="L186">        this.x = x;</span>
<span class="nc" id="L187">        this.y = y;</span>
<span class="nc" id="L188">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>